<?xml version="1.0" encoding="UTF-8"?>
<BES xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="BES.xsd">
	<Fixlet>
		<Title>/etc/security/login.cfg - logindisable - AIX 5.3-6.1</Title>
		<Description><![CDATA[
  <div class=FixletMessage>
      
<TABLE><TBODY><TR><TD><b>Description:</b><br><br>Defines the number of unsuccessful login attempts required before a port will be locked. This parameter is applicable to all tty connections and the system console.<br><p><br><b>Rationale:</b><br><br>In setting the logindisable attribute, a port will be disabled if the incorrect password is entered a set number of times within a specified interval, set via logininterval.<br><p><br><b>Remediation:</b><br><br>In /etc/security/login.cfg, set the default stanza logindisable attribute to be less than or equal to 10.<p>This means that the port will be disabled if the incorrect password is typed 10 times within a 300 second interval.<br><p><br><table border=0>&#xd;<br>	<tr>&#xd;<br>		<td>&#xd;<br>			High Level policy&#xd;<br>		</td>&#xd;<br>		<td>&#xd;<br>			logindisable = 10&#xd;<br>		</td>&#xd;<br>	</tr>&#xd;<br>	<tr>&#xd;<br>		<td>&#xd;<br>			Medium Level policy&#xd;<br>		</td>&#xd;<br>		<td>&#xd;<br>			logindisable = 10&#xd;<br>		</td>&#xd;<br>	</tr>&#xd;<br>	<tr>&#xd;<br>		<td>&#xd;<br>			Low Level policy&#xd;<br>		</td>&#xd;<br>		<td>&#xd;<br>			No Effect&#xd;<br>		</td>&#xd;<br>	</td>&#xd;<br></table>&#xd;<script>    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // JSON library json2.js (https://github.com/douglascrockford/JSON-js/raw/8e0b15cb492f63067a88ad786e4d5fc0fa89a241/json2.js)
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    var JSON;
    if (!JSON) {
        JSON = {};
    }

    (function () {
    	"use strict";

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf()) ?
                this.getUTCFullYear()     + '-' +
                f(this.getUTCMonth() + 1) + '-' +
                f(this.getUTCDate())      + 'T' +
                f(this.getUTCHours())     + ':' +
                f(this.getUTCMinutes())   + ':' +
                f(this.getUTCSeconds())   + 'Z' : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0 ? '{}' : gap ?
                '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
                '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());

////////////////////////////////// END OF JSON LIBRARY ///////////////////////////////////////

		// display the fixlet description
		var json = EvaluateRelevance('mime field "x-fixlet-scm-metadata" of current fixlet');
		metadata = JSON.parse(json);
		// document.write(metadata.description + '<hr>');
	
		// We might not have parameterization, have to deal with that also
	
		// write the parameterization form
		var editable_params = false;
		for (var key in metadata.scm_parameters ) {
			if ( key=="Value" ) {
				continue;
			}
			if ( "xhidden" in metadata.scm_parameters[key]) {
				if ( metadata.scm_parameters[key].xhidden!="true" ) {
					editable_params = true;
					break;
				}
			} else {
				if ( metadata.scm_parameters[key].hidden!="true" ) {
					editable_params = true;
					break;
				}
			}
		}
		if ( editable_params) {
			document.write('<form id="form"><table border=1>');
			document.write('<th colspan=2>Parameters</th>');
		}

		for (var key in metadata.scm_parameters ) {

			// if it doesn't have a default value it must be a measured value,
			// in any case we can't build an input widget for it.
			if ( typeof metadata.scm_parameters[key].default_value=="undefined") {
				continue;
			}

			if ( "xhidden" in metadata.scm_parameters[key]) {
				if ( metadata.scm_parameters[key].xhidden=="true") {
					continue;
				}
			} else {
				if ( metadata.scm_parameters[key].hidden=="true") {
					continue;
				}
			}

			document.write('<tr><td colspan=2><strong>' + metadata.scm_parameters[key].description + '</strong></td></tr>');
			document.write('<tr><td>Default Value:</td><td>' + metadata.scm_parameters[key].default_value + '</td></tr>');
			document.write('<tr><td>Current Value:</td><td><input size=100 id=' + key + '></td></tr>');

			// populate stuff with the current "effective" value
			if ( typeof metadata.scm_parameters[key].desired_value!="undefined" ) {
				document.getElementById(key).value = metadata.scm_parameters[key].desired_value;
			} else {
				document.getElementById(key).value = metadata.scm_parameters[key].default_value;
			}
		
		}

		if ( editable_params) {
			document.write('<tr><td><INPUT id=id_submit onclick="apply(); return false;" type=submit value=Apply></td><td>Note: Parameters can only be set on a custom copy of this check</td></tr></table></FORM>');

		}

	function handleError(error) {

		// The user has cancelled the transaction by pressing ESC or the Cancel button
		if (error.message == 'class UserCancelled') {
			return;
		}

		if (/you do not have permission to edit/.test(error.message)) {
			alert('This fixlet must be copied to a custom site before any parameters can be set.');
			return;
		}

		alert('There was a problem: ' + error.message);

	}


	function apply() {

		// Get an XML DOM document with the data for this fixlet.
		var xml = new ActiveXObject("Msxml2.DOMDocument");
		xml.loadXML(EvaluateRelevance('current fixlet as xml'));
		xml.setProperty("SelectionLanguage", "XPath");


		//var sourceID = xml.selectSingleNode("/BES/Fixlet/SourceID").text;
		var sourceID = xml.selectSingleNode("//SourceID").text;
		var newparams = sourceID + ':';
		for (var key in metadata.scm_parameters ) {

			// if it doesn't have a default value it must be a measured value,
			// in any case we can't build an input widget for it.
			if (typeof metadata.scm_parameters[key].default_value=="undefined") {
				continue;
			}
			var pvalue = metadata.scm_parameters[key].default_value;
			if ( "xhidden" in metadata.scm_parameters[key]) {
				if ( metadata.scm_parameters[key].xhidden=="true") {
					newparams += key + '="' + pvalue + '";';
					continue;
				}
			} else {
				if ( metadata.scm_parameters[key].hidden=="true") {
					newparams += key + '="' + pvalue + '";';
					continue;
				}
			}
			newval = document.getElementById(key).value;
			keytypestr = key + "_TYPE";
			keytype = metadata.scm_parameters[keytypestr]
			if (typeof keytype != "undefined") {
				switch (keytype.default_value) {
					case "num":
						if (newval.match(/^\d+$/) == null) {
							alert(metadata.scm_parameters[key].description + " must be a number");
							return;
						}
						break;
					case "perms":
						if (newval.match(/^[0-7]{1,4}$/) == null) {
							alert(metadata.scm_parameters[key].description + " must be four digit octal");
							return;
						}
						break;
					default:	// this is the list one
						mylist = keytype.default_value.split(" ");
						found=false;
						for (var myele in mylist) {
							if (mylist[myele] == newval) {
								found = true;
								break;
							}
						}
						if (! found) {
							alert(metadata.scm_parameters[key].description + " must be in the list: " + keytype.default_value);
							return;
						}
						
				}
			}
			//metadata.scm_parameters[key].desired_value = document.getElementById(key).value;
			metadata.scm_parameters[key].desired_value = newval;
			// remove desired_value if same as default_value
			if ( metadata.scm_parameters[key].desired_value == metadata.scm_parameters[key].default_value ) {
				delete metadata.scm_parameters[key].desired_value
			}
			// build new xml params string
			if (typeof metadata.scm_parameters[key].desired_value!="undefined") {
				pvalue = metadata.scm_parameters[key].desired_value;
			}
			newparams += key + '="' + pvalue + '";';

		}
		// serialize tha data
		var newjson = JSON.stringify(metadata);
		// update x-fixlet-scm-metadata
		//xml.selectSingleNode("/BES/Fixlet/MIMEField/Name[.='x-fixlet-scm-metadata']/../Value").text = newjson;
		xml.selectSingleNode("//MIMEField/Name[.='x-fixlet-scm-metadata']/../Value").text = newjson;

		// Update the MIME field storing the paramete value
		//var value = document.getElementById("parameter_value").value;
		//xml.selectSingleNode("/BES/Fixlet/MIMEField/Name[.='x-fixlet-scm-parameter-value']/../Value").text = value;

		// Fill out the parameter template.
		//var parameterTemplate = xml.selectSingleNode("/BES/Fixlet/MIMEField/Name[.='x-fixlet-scm-parameter-template']/../Value" ).text;
		// and finally apply it to the place where it actually gets used x-fixlet-scm-parameters
		//xml.selectSingleNode("/BES/Fixlet/MIMEField/Name[.='x-fixlet-scm-parameters']/../Value").text = parameterTemplate.replace(/{{value}}/g, value);
		//xml.selectSingleNode("/BES/Fixlet/MIMEField/Name[.='x-fixlet-scm-parameters']/../Value").text = newparams;
		xml.selectSingleNode("//MIMEField/Name[.='x-fixlet-scm-parameters']/../Value").text = newparams;

		// Update ourself.
		try {
			EditFixlet(EvaluateRelevance('id of current fixlet'), xml.xml);
		} catch (e) {
			handleError(e);
		}
			
	}
</script><br><BR><BR>After the system scan has been completed you can click on the following link to see the actual values configured on each system: <?relevance links of bes fixlets whose (analysis flag of it and mime field "X-Fixlet-SCM-Analysis-ID" of it = "1.3.6.1.4.1.1466.115.121.1.15.bigfix_emeryville/DISA/AIX/61/CIS-1.2.2" AND (if (custom site flag of site of current fixlet) then name of site of it = name of site of current fixlet else id of site of it = id of site of current fixlet) of it)?></TD></TR></TBODY></TABLE>

  </div>
  ]]></Description>
		<Relevance><![CDATA[(name of operating system = "AIX 5.3" OR name of operating system = "AIX 6.1" ) AND (version of client >= "8.1.551.0")]]></Relevance>
		<Relevance><![CDATA[line ((line number of it + 1 ) of lines whose (it contains "[STATUS]") of file "CIS-1.2.2.results" of folders ( (  ( pathname of client folder of current site) ) & "/SCM/mytmp/results")) of file "CIS-1.2.2.results" of folders ( (  ( pathname of client folder of current site) ) & "/SCM/mytmp/results") = "FAIL"]]></Relevance>
		<Category><![CDATA[<none>]]></Category>
		<DownloadSize>0</DownloadSize>
		<Source>CIS IBM AIX 5.3 and AIX 6.1 Version 1.0.0</Source>
		<SourceID>CIS-1.2.2</SourceID>
		<SourceReleaseDate>2010-12-21</SourceReleaseDate>
		<SourceSeverity>Level-1</SourceSeverity>
		<MIMEField>
			<Name>x-fixlet-scm-linkid</Name>
			<Value>57218</Value>
		</MIMEField>
		<MIMEField>
			<Name>x-fixlet-scm-id</Name>
			<Value>1.3.6.1.4.1.1466.115.121.1.15.bigfix_emeryville/DISA/AIX/61/CIS-1.2.2</Value>
		</MIMEField>
		<MIMEField>
			<Name>x-fixlet-first-propagation</Name>
			<Value>Wed, 25 Apr 2012 18:58:42 +0000</Value>
		</MIMEField>
		<MIMEField>
			<Name>x-fixlet-scm-metadata</Name>
			<Value><![CDATA[{"scm_parameters":{"FILE":{"default_value":"/etc/security/login.cfg","hidden":"true","title":"FILE","type":"string","description":"FILE: ","xhidden":"true"},"Value":{"measured_value_analysis_property":1,"measured_value_analysis_idref":"1.3.6.1.4.1.1466.115.121.1.15.bigfix_emeryville/DISA/AIX/61/CIS-1.2.2"},"VALUE":{"default_value":"10","title":"less than or equal to","type":"string","description":"VALUE: This Parameter corresponds to the logindisable setting in /etc/security/login.cfg for the default stanza.","xhidden":"false"},"OPDESC":{"default_value":"less than or equal to","hidden":"true","title":"OPDESC","type":"string","description":"OPDESC: ","xhidden":"true"},"VALUE_DVTITLE":{"default_value":"less than or equal to","hidden":"true","title":"VALUE_DVTITLE","type":"string","description":"VALUE_DVTITLE: ","xhidden":"true"},"DESIRED_VALUE":{"default_value":"VALUE","hidden":"true","title":"DESIRED_VALUE","type":"string","description":"DESIRED_VALUE: ","xhidden":"true"},"OP":{"default_value":"-le","hidden":"true","title":"OP","type":"string","description":"OP: ","xhidden":"true"},"STANZA":{"default_value":"default","hidden":"true","title":"STANZA","type":"string","description":"STANZA: ","xhidden":"true"},"ATTRIBUTE":{"default_value":"logindisable","hidden":"true","title":"ATTRIBUTE","type":"string","description":"ATTRIBUTE: ","xhidden":"true"}},"title":"/etc/security/login.cfg - logindisable","description":"<b>Description:</b><BR>Defines the number of unsuccessful login attempts required before a port will be locked. This parameter is applicable to all tty connections and the system console.<BR><p><BR><b>Rationale:</b><BR>In setting the logindisable attribute, a port will be disabled if the incorrect password is entered a set number of times within a specified interval, set via logininterval.<BR><p><BR><b>Remediation:</b><BR>In /etc/security/login.cfg, set the default stanza logindisable attribute to be less than or equal to 10.<p>This means that the port will be disabled if the incorrect password is typed 10 times within a 300 second interval.<BR><p><BR>"}]]></Value>
		</MIMEField>
		<MIMEField>
			<Name>x-fixlet-remediate-script0</Name>
			<Value>CIS-1.2.2.remediate:IyEvYmluL3NoIC14CgpTQ1JJUFRMRVRfU1RBUlRfVElNRT1gLi91dGlsL2dldF9lcG9jaF9zZWNvbmRzYApNRT1gYmFzZW5hbWUgJDAgLnJlbWVkaWF0ZWAKTE9HX0RJUj0ke0JGVE1QRElSfS9yZXN1bHRzClJFU1VMVFNfRklMRT0ke0xPR19ESVJ9LyR7TUV9LnJlc3VsdHMKVE1QRklMRT0ke0JGVE1QRElSfS90bXAvJHtNRX0udG1wLiQkCgouIC4vdXRpbC9nZXRwYXJhbXMKCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCgpSRVNVTFQ9UEFTUwpDVVJSRU5UX1NFVFRJTkc9YGxzc2VjIC1mICRGSUxFIC1zICRTVEFOWkEgLWEgJEFUVFJJQlVURSB8IGF3ayAtRj0gJ3twcmludCAkTkZ9J2AKaWYgWyB4JENVUlJFTlRfU0VUVElORyA9IHggXQp0aGVuCglSRVNVTFQ9RkFJTAplbHNlCglpZiBbICEgJENVUlJFTlRfU0VUVElORyAkT1AgJFZBTFVFIF0KCXRoZW4KCQlSRVNVTFQ9RkFJTAoJZmkKZmkKCmlmIFsgJFJFU1VMVCA9IEZBSUwgXQp0aGVuCiAgICAgICAgbWtkaXIgLXAgIiRCQUNLVVAvYGRpcm5hbWUgJEZJTEVgIgogICAgICAgIGNwIC1wICRGSUxFICAiJEJBQ0tVUC9gZGlybmFtZSAkRklMRWAvYGJhc2VuYW1lICRGSUxFYC4kU0NSSVBUTEVUX1NUQVJUX1RJTUUiCiAgICAgICAgY2F0ID4gJEJBQ0tVUC9yb2xsYmFjay8kTUUucm9sbGJhY2sgPDxFT0YKIyEvYmluL3NoCmNwIC1wICRCQUNLVVAvJEZJTEUuJFNDUklQVExFVF9TVEFSVF9USU1FICRGSUxFCkVPRgogICAgICAgIGNobW9kIDcwMCAkQkFDS1VQL3JvbGxiYWNrLyRNRS5yb2xsYmFjawogICAgICAgIGNoc2VjIC1mICRGSUxFIC1zICRTVEFOWkEgLWEgJEFUVFJJQlVURT0kVkFMVUUKZmkKCiMjIyMjIyMjIyMjIyMjIyMjCiMgbG9nbW9kdWxlICAgICAjCiMgR3V0cyBlbmQgaGVyZSAjCiMjIyMjIyMjIyMjIyMjIyMjCi4gLi91dGlsL2xvZ21vZHVsZQoK</Value>
		</MIMEField>
		<MIMEField>
			<Name>x-fixlet-scm-os</Name>
			<Value>AIX 61</Value>
		</MIMEField>
		<MIMEField>
			<Name>x-fixlet-scm-parameters</Name>
			<Value>CIS-1.2.2:FILE="/etc/security/login.cfg";VALUE="10";OPDESC="less than or equal to";VALUE_DVTITLE="less than or equal to";DESIRED_VALUE="VALUE";OP="-le";STANZA="default";ATTRIBUTE="logindisable";</Value>
		</MIMEField>
		<MIMEField>
			<Name>x-fixlet-scm-control</Name>
			<Value>CIS-1.2.2</Value>
		</MIMEField>
		<MIMEField>
			<Name>x-fixlet-scm-sentinel-idref</Name>
			<Value>cpe:/o:ibm:aix:5.3,o:ibm:aix:6.1</Value>
		</MIMEField>
		<MIMEField>
			<Name>x-fixlet-detect-script0</Name>
			<Value>CIS-1.2.2.detect:IyEvYmluL3NoCgpTQ1JJUFRMRVRfU1RBUlRfVElNRT1gLi91dGlsL2dldF9lcG9jaF9zZWNvbmRzYApNRT1gYmFzZW5hbWUgJDAgLmRldGVjdGAKTE9HX0RJUj0ke0JGVE1QRElSfS9yZXN1bHRzClJFU1VMVFNfRklMRT0ke0xPR19ESVJ9LyR7TUV9LnJlc3VsdHMKVE1QRklMRT0ke0JGVE1QRElSfS90bXAvJHtNRX0udG1wLiQkCj4kVE1QRklMRQouIC4vdXRpbC9nZXRwYXJhbXMKCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiMgR3V0cyBnbyBoZXJlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjCiMgTk9URTogeW91IGhhdmUgdG8gaW1wbGVtZW50IFJFU1VMVD1bUEFTU3xGQUlMfE5BfEVSUl0gYW5kIFJFQVNPTj0idGhpcyBpcyB0aGUgcmVhc29uIiAjCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCgpSRVNVTFQ9UEFTUwpSRUFTT049IlRoZSAkU0VUVElORyBzZXR0aW5nIGZvciB0aGUgJFNUQU5aQSBzdGFuemEgaW4gJEZJTEUgaXMgc2V0IHRvICRPUERFU0MgJFZBTFVFIgoKQ1VSUkVOVF9TRVRUSU5HPWBsc3NlYyAtZiAkRklMRSAtcyAkU1RBTlpBIC1hICRBVFRSSUJVVEUgfCBhd2sgLUY9ICd7cHJpbnQgJE5GfSdgCmlmIFsgIngkQ1VSUkVOVF9TRVRUSU5HIiA9ICJ4IiBdCnRoZW4KCVJFU1VMVD1GQUlMCglSRUFTT049IiRBVFRSSUJVVEUgaXMgbm90IHByZXNlbnQgaW4gdGhlICRTVEFOWkEgc3RhbnphIG9mICRGSUxFIgoJZWNobyAibm90IHNldCIgPiAkVE1QQU5BTFlTSVMKZWxzZQoJaWYgWyAhICIkQ1VSUkVOVF9TRVRUSU5HIiAkT1AgIiRWQUxVRSIgXQoJdGhlbgoJCVJFU1VMVD1GQUlMCgkJUkVBU09OPSJUaGUgJEFUVFJJQlVURSBzZXR0aW5nIGluIHRoZSAkU1RBTlpBIHN0YW56YSBvZiAkRklMRSBpcyBub3Qgc2V0IHRvICRPUERFU0MgJFZBTFVFIgoJZmkKCWVjaG8gIiRDVVJSRU5UX1NFVFRJTkciID4gJFRNUEFOQUxZU0lTCmZpCgojIyMjIyMjIyMjIyMjIyMjIwojIGxvZ21vZHVsZSAgICAgIwojIEd1dHMgZW5kIGhlcmUgIwojIyMjIyMjIyMjIyMjIyMjIwouIC4vdXRpbC9sb2dtb2R1bGUKCg==</Value>
		</MIMEField>
		<MIMEField>
			<Name>x-fixlet-scm-category</Name>
			<Value><![CDATA[<none>]]></Value>
		</MIMEField>
		<MIMEField>
			<Name>x-fixlet-modification-time</Name>
			<Value>Fri, 26 Jul 2019 06:42:55 +0000</Value>
		</MIMEField>
		<Domain>BESC</Domain>
		<Action ID="Action1">
			<Description>
				<PreLink>Click </PreLink>
				<Link>here</Link>
				<PostLink> to remediate this issue.</PostLink>
			</Description>
			<ActionScript MIMEType="application/x-Fixlet-Windows-Shell">wait /bin/sh -c "cd SCM; ./runme.sh -r CIS-1.2.2"</ActionScript>
		</Action>
	</Fixlet>
</BES>
